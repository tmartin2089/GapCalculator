/* -------------------------Table of Contents-------------------------
	Howto -	Ctrl-F for the caret and # you want i.e. "^2" for bio functions  
  ^1 - This section gathers and parses p6 paste into a useful object
  ^2 - Gathers and parses bio information - budget/pc/sc/st res gift
  ^3 - Calculates need/this is skipped if no NB aid
  ^4 - 
  ^5 - 
  ^6 -
  ^7 - 
  ^8 -
 
 */

 
 //helpful functions - determine onlysacredAid?  if so - skip all calcs 
 //helpful functions - determine noneedbasedAid - if so skip all need calcs
 //helpful function - total NBA less than need - skip need redux entirely


"use strict";



//global = bad bad dev, let mama mytestScope protect your pretty variables in her safe scoped arms
var mytestScope = (function(){

//this is the processed aid object that we will be referencing so we don't keep calling the  function like in the bad old days	
	var aidObject = runitThrough(newgetPaste());

	function gatherBio(){
		var bio = [];
		$('.bio').each(function(index){
			//NaN = falsey 
			if(parseInt($(this).val())){
				bio.push(parseInt($(this).val()));
			}
			else{
				bio.push(0);
			}
		});
		console.log(bio);
		return bio;
	}


	//gather p6 paste information and clean it up
	function newgetPaste(){
		//clean up your input
		var pasted = $('.paste').val().replace(/_/g,' ').split(' '); //remove underscores
		var pastedArray = [];
		var pastedArray2 = [];
		//get rid of big ol' words
		$.each(pasted,function(){
			if(parseInt(this) && (parseInt(this) > 10)){ //to avoid top 10% counted as amt
				pastedArray.push(parseInt(this));
			}
		})
		//convert into prelim object array for later conversionObject
		//added as separate each statement for ease of comprehension/I really dont want to put together a longer boolean in the above
		$.each(pastedArray,function(index){
			if((index % 2) === 0){
				pastedArray2.push({type:this, value:pastedArray[index+1]});
			}
		})
		//convert all OSFS scholarships to same type
		$.each(pastedArray2,function(index){
			var testVar = this.type;
				if(testVar.toString().substring(0,3)==="331" || testVar.toString().substring(0,3)==="341"){
					pastedArray2[index].type = 331000;
				}				
		})
		return pastedArray2;	
	}



	//needRank determines order of reduction.  Lowest needRank gets reduced first  needBased flag will be used to gather need objects only for need redux

	//will need to look for (!object.sacred) to exclude pell & etc 

	//convert p6 array input through object literal call - richer return than switch statement
	function runitThrough(thingy){
		var k = [];
		$.each(thingy, function(){
			k.push(convertAid(this.type, this.value));
		})
		//filters out undefined values generated by no match <oschs>
		k = k.filter(function(x){
			return (x);
		})
		console.log(k);
		return k;
	}
	
	//lets attempt to make one adding function so we don't have to litter our code with multiple
	//cost and need adder uppers 
	//consider adding flag to parameters being passed to additup so the function knows what it's
	//adding up - i.e. flag = need or flag = cost, then will only check for aid.flag === need etc.
	function additUp(aid, flag){
		var need = 0;
		$.each(aid, function(){
			console.log(aid);
			if(flag === "need"){
				if(this.needBased){
					need += this.amount;
				}
			}
		})
		console.log(need);
	}

gatherBio();
additUp(aidObject, "need");
	

});   //end mytestScope


$('#onf').on("click",function(){
		mytestScope();
		
});
